<p-slide class="cover">
  <h1>Partiamo dall’inizio…Signal?</h1>
  <p-fragment class="center">
    <img alt="so-confused" src="img/so-confused.gif" />
  </p-fragment>
</p-slide>
<p-slide class="slide-quote center">
  <p-note class="text-sub-section" style="font-size: 1.8vw; line-height: 3vw"
    >“Signals are the primary means of managing state in your Solid application. They provide a way to store and update values, and are the foundation of reactivity in Solid.
    Signals can be used to represent any kind of state in your application, such as the current user, the current page, or the current theme. This can be any value, including
    primitive values such as strings and numbers, or complex values such as objects and arrays. ”
  </p-note>
  <p-note style="font-size: 1.5vw"> https://docs.solidjs.com/concepts/signals </p-note>
</p-slide>
<p-slide timing-fragment="1000" autoplay="signal-caratteristiche">
  <h4 style="margin-bottom: 0.7em">🙌 Signal 🙌</h4>
  <ul class="long-list">
    <p-fragment timing-start="300"><li>📌 Un signal contiene sempre un valore</li></p-fragment>
    <p-fragment><li>📌 Al suo variare, chiunque lo utilizzi è in grado di accedere al nuovo valore</li></p-fragment>
    <p-fragment><li>📌 La reattività di signal è sincrona ed il suo valore viene propagato istantaneamente</li></p-fragment>
    <p-fragment
      ><li>📌 E’ possibile “iscriversi” e reagire tramite i consumer, come ad esempio <b>effect</b></li></p-fragment
    >
  </ul>
</p-slide>
<p-slide timing-fragment="1000" autoplay="signal-caratteristiche-pt2">
  <h4 style="margin-bottom: 0.7em">🙌 Signal 🙌</h4>
  <ul class="long-list">
    <p-fragment timing-start="300"><li>📌 Ogni singolo signal è chiamato “producer”</li></p-fragment>
    <p-fragment
      ><li>📌 Sia i template sia le funzioni che “leggono” i signal (es: <u>computed</u> ed <u>effect</u>) sono chiamati <b>“consumer”</b></li></p-fragment
    >
    <p-fragment><li>📌 Quando questo accade, si crea una “connessione” tra producer <-> consumer simile alla subscription negli observable</li></p-fragment>
    <p-fragment><li>📌 I producer inviano una notifica di aggiornamento e non direttamente il nuovo valore, che andrà così esplicitamente letto</li></p-fragment>
    <p-fragment><li>📌 Il consumer potrà decidere di leggere il valore oppure non farlo mai.</li></p-fragment>
    <p-fragment><li>📌 Le funzioni computed, producendo a loro volta un signal, sono contemporaneamente producer and consumer</li></p-fragment>
    <p-fragment><li>📌 I consumer sono memoized by default.</li></p-fragment>
  </ul>
</p-slide>
<p-slide>
  <pre class="language-javascript" data-label-file="app.component.ts"><code class="small-line">
    import {signal} from '@angular/core';
    //...
    export default function AppComponent() {
      myFirstSignal = signal&lt;number> (1);

      constructor() {</code>
      <p-fragment><code>console.log('My first signal: ', this.myFirstSignal());
      // Output: My first signal: 1</code></p-fragment>
    <code>}
  </code></pre>
</p-slide>
<p-slide>
  <h4 class="text-cover" style="margin-bottom: 0.7em">↔ Signal - Computed ↔</h4>
  <ul class="long-list">
    <p-fragment><li>📌 E’ possibile creare signal definiti “computed” che dipendono dal valore di altri signal</li></p-fragment>
    <p-fragment><li>📌 Le dipendenze sono dinamiche e possono essere incluse in statement condizionali</li></p-fragment>
    <p-fragment><li>📌 Sono memoized e lazy evaluated</li></p-fragment>
    <p-fragment><li>📌 L’intera computazione viene eseguita unicamente al variare dei valori dei suoi consumer e solo se esplicitamente “letti”</li></p-fragment>
    <p-fragment
      ><li>📌 <b>Sono read only</b></li></p-fragment
    >
  </ul>
</p-slide>
<p-slide follow-fragments>
  <pre class="line-numbers small-line language-javascript" data-label-file="app.component.ts"><code class="mid-dimension">    import {signal, computed} from '@angular/core';
    //...
    export default function AppComponent() {
        myFirstSignal = signal&lt;number> (1);</code>
     <p-fragment><code class="mid-dimension">runs = 0;</code></p-fragment>
     <p-fragment><code class="mid-dimension">myFirstComputedSignal = computed(() => {
          runs++;
          return myFirstSignal() * 2;
        });</code></p-fragment>
      <code class="mid-dimension">
      constructor() {</code>
     <p-fragment><code class="mid-dimension">console.log('My computed signal: ', this.myFirstComputedSignal());
        // Output: My computed signal: 2
        console.log('Number of runs: ', this.runs);
        // Output: Number of runs: 1 <-- 1 because the computed signal as been read once
        </code></p-fragment>
     <p-fragment><code class="mid-dimension">this.myFirstComputedSignal();
        console.log('Number of runs: ', this.runs);
        // Output: Number of runs: 1 <-- still 1 because the value of the signal hasn't changed
        </code></p-fragment>
     <p-fragment><code class="mid-dimension">this.myFirstSignal.set(2);
        console.log('Number of runs: ', this.runs);
        // Output: Number of runs: 1 <-- because the computed signal as not read again
        </code></p-fragment>
     <p-fragment><code class="mid-dimension">console.log('My second computed signal: ', this.myFirstComputedSignal());
        // Output: My second computed signal: 4
        console.log('Number of runs: ', this.runs);
        // Output: Number of runs: 2 <-- because the computed signal as been read again
        </code></p-fragment>
        <code class="mid-dimension">}
      }
  </code></pre>
</p-slide>
<p-slide>
  <pre class="small-line language-javascript" data-label-file="app.component.ts"><code class="small-text">    import {signal, computed} from '@angular/core';
    //...
    export default function AppComponent() {
       myFirstSignal = signal&lt;number> (1);
       runs = 0;
       myFirstComputedSignal = computed(() => {
        runs++;
        return myFirstSignal() * 2;
      });
      constructor() {</code>
    <p-fragment><code class="small-text">this.myFirstComputedSignal();
        console.log('Number of runs: ', this.runs);
        // Output: Number of runs: 1 <-- still 1 because the value of the signal hasn't changed
      </code></p-fragment><code class="small-text">}
  </code></pre>
</p-slide>
