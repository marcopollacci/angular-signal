<p-slide class="cover-subSection">
  <h1>Ultime novitÃ </h1>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row; align-items: center">
  <p-note class="my-presentation my-list">
    <h5 class="text-cover">Signal Inputs</h5>
    <ul class="long-list">
      <li>ðŸ“Œ ModalitÃ  di gestione della logica di change input molto piÃ¹ facile</li>
      <li>ðŸ“Œ Integrazione piÃ¹ efficace con la onPush strategy</li>
      <li>ðŸ“Œ Effect sostituisce ngOnChanges</li>
      <li>ðŸ“Œ Nessuna breaking change per i componenti padre (allo stato attuale della preview)</li>
      <li>ðŸ“Œ Eâ€™ possibile definire un nome alternativo attraverso la proprietÃ  alias di input</li>
    </ul>
  </p-note>
  <p-note style="font-size: 0.5em">
    <pre class="self-center language-javascript" style="border: 1px solid #101099"> <code> export class InputComponent {
      firstName = input&lt;string>();
      // required inputs
      lastName = input.required&lt;string>();
  } </code>
      <p-fragment><code class="self-center language-html">
  &lt;app-input lastName="Doe">&lt;/app-input> </code> </p-fragment> </pre>
  </p-note>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row; align-items: center">
  <p-note class="my-presentation my-list">
    <ul class="long-list">
      <li>
        Eâ€™ inoltre possibile effettuare operazioni di trasformazione alla ricezione dellâ€™input tramite la proprietÃ  transform, sia mantenendo il tipo di output che cambiandolo
        completamente
      </li>
    </ul>
  </p-note>
  <p-note style="font-size: 0.5em">
    <pre class="self-center language-javascript" style="border: 1px solid #101099"><code>export class InputComponent {
  firstName = input&lt;number, string>(0, {
  </code> <p-fragment><code>alias: 'first',
  </code></p-fragment> <p-fragment><code>transform: (value) => value.length,
 </code></p-fragment> <code>});
}
  </code><p-fragment><code class="self-center language-html">
&lt;app-input first="'Marco'">&lt;/app-input> </code></p-fragment><p-fragment> <code
      class="self-center language-javascript">

//Output: 5
</code> </p-fragment> </pre>
  </p-note>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row; align-items: center">
  <p-note class="my-presentation my-list" style="align-items: flex-start">
    <h6 class="text-cover">viewChild / viewChildren</h6>
    <h6 class="text-cover">contentChild / contentChildren</h6>
    <ul class="long-list" style="margin-top: 1em">
      <li>ðŸ“Œ Sostituzione dei decorators con api signal-based</li>
      <li>ðŸ“Œ Utilizzo di effect al posto dellâ€™afterviewinit lifecycle</li>
      <li>ðŸ“Œ contentChild / contentChildren possono essere usati con lo stesso approccio</li>
    </ul>
  </p-note>
  <p-note style="font-size: 0.5em">
    <pre class="self-center language-javascript" style="border: 1px solid #101099">
      <code>
  @Component({
    ...
    template: `
      &lt;h1>SomeComponent&lt;/h1>
      &lt;app-input lastName="Pollacci" />
    `,
    imports: [InputComponent],
  })
  export class SomeComponent {</code>
    <p-fragment><code>childComponent = viewChild(InputComponent);</code></p-fragment>
     <code>constructor() {</code>
      <p-fragment><code>effect(() => {
        console.log(this.childComponent()!.lastName())
        // Output: Pollacci
      })</code></p-fragment>
    <code>}
  }
      </code>
    </pre>
  </p-note>
</p-slide>
