<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>Angular Signal</title>
  <base href=".." />
  <link href="favicon.ico" rel="shortcut icon" type="image/svg+xml" />
  <link href="css/prism-one-light.css" rel="stylesheet" />
  <link href="css/main.css" rel="stylesheet" />
  <link href="css/print.css" media="print" rel="stylesheet" />
  <link href="css/presentation.css" rel="stylesheet" />
</head>

<body>
<img alt="gdglogo" class="gdgLogo" src="img/logo_dark_QmPdj9K.svg" />
<p-deck>
  <!--slide:cover--><p-slide class="cover">
  <h1>Guida Essenziale all'Integrazione di Angular e Signal</h1>
   <p-note class="center">
     <h6>Un approccio pratico</h6>
  </p-note>
</p-slide>
<p-slide class="two-columns">
  <p-note class="my-data my-presentation">
    <h5 class="text-cover">Hello Folks!</h5>
    <img src="img/me.jpg" class="my-face" alt="me" />
    <span>Marco Pollacci</span>
    <span class="text-cover">Senior Software Developer @GELLIFY</span>
  </p-note>
    <img src="img/qr_link.png" alt="qr" />
</p-slide><!--/slide:cover-->
  <!--slide:part-one--><p-slide class="cover">
  <h1>Partiamo dallâ€™inizioâ€¦Signal?</h1>
  <p-fragment class="center">
    <img alt="so-confused" src="img/so-confused.gif" />
  </p-fragment>
</p-slide>
<p-slide class="slide-quote center">
  <p-note class="text-sub-section" style="font-size: 1.8vw; line-height: 3vw">â€œSignals are the primary means of managing
    state in your Solid application.
    They provide a way to store and update values, and are the foundation of reactivity in Solid.

    Signals can be used to represent any kind of state in your application, such as the current user, the current page,
    or the current theme.

    This can be any value, including primitive values such as strings and numbers, or complex values such as objects and
    arrays.
    â€
  </p-note>
  <p-note style="font-size: 1.5vw;">
    https://docs.solidjs.com/concepts/signals
  </p-note>
</p-slide>
<p-slide class="two-columns-flex-start">
  <p-note class="my-presentation my-list">
    <h5 class="text-cover">Signal</h5>
    <ul class="long-list">
      <li>ğŸ“Œ Un signal contiene sempre un valore</li>
      <li>ğŸ“Œ Al suo variare, chiunque lo utilizzi Ã¨ in grado di accedere al nuovo valore</li>
      <li>ğŸ“Œ La reattivitÃ  di signal Ã¨ sincrona ed il suo valore viene propagato istantaneamente</li>
      <li>ğŸ“Œ Eâ€™ possibile â€œiscriversiâ€ e reagire tramite consumer, come ad esempio <b>effect</b></li>
      <li>ğŸ“Œ Per poter usare effect al di fuori del costruttore Ã¨ necessario lâ€™injector tra le sue opzioni</li>
    </ul>

  </p-note>
  <img alt="qr" src="img/export_1.png" style="padding-top: 5vh" />
</p-slide>
<p-slide class="two-columns-flex-start">
  <p-note class="my-presentation my-list">
    <h5 class="text-cover">Signal</h5>
    <ul class="long-list" style="margin-bottom: 0.5vh">
      <li>ğŸ“Œ Ogni singolo signal Ã¨ chiamato â€œproducerâ€</li>
      <li>ğŸ“Œ Sia i template sia le funzioni che â€œleggonoâ€ i signal (es: <u>computed</u> ed <u>effect</u>) sono chiamati
        <b>â€œconsumerâ€</b></li>
      <li>ğŸ“Œ Quando questo accade, si crea una â€œconnessioneâ€ tra producer <-> consumer simile alla subscription negli
        observable
      </li>
      <li>ğŸ“Œ I producer inviano una notifica di aggiornamento e non direttamente il nuovo valore, che andrÃ  cosÃ¬
        esplicitamente letto
      </li>
      <li>ğŸ“Œ Il consumer potrÃ  decidere di leggere il valore oppure non farlo mai.</li>
      <li>ğŸ“Œ Le funzioni computed, producendo a loro volta un signal, sono contemporaneamente producer and consumer
      </li>
      <li>ğŸ“Œ I consumer sono memoized by default.</li>
    </ul>
  </p-note>
  <img alt="qr" src="img/export_1.png" style="padding-top: 5vh" />
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row;flex-wrap: nowrap;">
  <p-note class="my-presentation my-list">
    <h5 class="text-cover">Signal</h5>
    <ul class="long-list">
      <li>ğŸ“Œ Eâ€™ possibile creare signal definiti â€œcomputedâ€ che dipendono dal valore di altri signal.</li>
      <li>ğŸ“Œ Le dipendenze sono dinamiche e possono essere incluse in statement condizionali</li>
      <li>ğŸ“Œ Sono memoized e lazy evaluated</li>
      <li>ğŸ“Œ Lâ€™intera computazione viene eseguita unicamente al variare dei valori dei suoi consumer e solo se
        esplicitamente â€œlettiâ€
      </li>
      <li>ğŸ“Œ <b>Sono read only</b></li>
    </ul>

  </p-note>
  <img alt="qr" src="img/export_2.png" style="padding-top: 0;transform: scale(0.95);" />
  <p-fragment class="invert"
              style="position: absolute;right: 1em;width: 9.5em;height: 1em;background: #FFF;top: 8.7em;"></p-fragment>
  <p-fragment class="invert"
              style="position: absolute;right: 1.5em;width: 9.5em;height: 1em;background: #FFF;top: 9.7em;"></p-fragment>
  <p-fragment class="invert"
              style="position: absolute;right: 1em;width: 9.5em;height: 2em;background: #FFF;top: 10.7em;"></p-fragment>
</p-slide>
<p-slide class="cover-subSection">
  <h1>Observable vs Signal</h1>
</p-slide>
<p-slide>
  <h5 class="text-cover center">Observable vs Signal</h5>
  <div class="two-columns">
    <p-note>
      <ul class="long-list">
        <li>â˜ï¸Gli observable possono non emettere alcun valore</li>
        <li>â˜ï¸Gli observable emettono i valori in maniera sincrona ed asincrona</li>
        <li>â˜ï¸Gli observable hanno il concetto di stato â€œcompleteâ€</li>
      </ul>
    </p-note>
    <p-note>
      <ul class="long-list">
        <li>â˜ï¸Signal ha sempre almeno un valore (alla sua creazione)</li>
        <li>â˜ï¸Signal non emette nulla se non la notifica di un cambio di valore, che deve essere â€œpulledâ€ dal consumer
          che avviene in maniera sincrona
        </li>
        <li>â˜ï¸Signal non presenta il concetto di stato complete
        </li>
      </ul>
    </p-note>
  </div>
</p-slide>
<p-slide>
  <h5 class="text-cover center">Observable vs Signal</h5>
  <div class="two-columns" style="align-items: center;">
    <img alt="code_03" src="img/export_3.png" />
    <ul class="long-list">
      <p-fragment>
        <li>âœ” combineLatest non emette nulla finchÃ© almeno uno dei due observable non ha almeno un valore</li>
      </p-fragment>
      <p-fragment>
        <li>âœ” Computed garantisce il â€œglitch-freeâ€ infatti ad ogni cambio di valore non viene emesso alcunchÃ© se non una
          semplice notifica che previene lâ€™esecuzione indesiderata del codice
        </li>
      </p-fragment>
    </ul>
  </div>
</p-slide>
<p-slide>
  <h5 class="text-cover center">Observable vs Signal</h5>
  <div class="two-columns" style="align-items: center;">
    <img alt="code_04" src="img/export_4.png" />
    <ul class="long-list">
      <p-fragment>
        <li>La differenza maggiore in questo caso Ã¨ che merge(), quando uno degli observable passati Ã¨ completo,
          continuerÃ 
          a emettere valori solo dagli observable non completi e ignorerÃ  gli altri. Comportamento che computed non ha
        </li>
      </p-fragment>
    </ul>
  </div>
</p-slide><!--/slide:part-one-->
  <!--slide:part-two--><p-slide class="cover-subSection">
  <h1>Signal: esempi di utilizzo</h1>
</p-slide>
<p-slide class="cover">
  <h1>Todo List</h1>
</p-slide>
<p-slide>
  <div class="two-columns" style="align-items: center;">
    <div><img alt="code_05" src="img/export_5.png" style="height: 100vh; transform: scale(0.8)" /></div>
    <div class="two-columns" style="flex-direction: column">
      <img alt="code_06" src="img/export_6.png"
           style="width: fit-content;height: 50vh;max-width: -webkit-fill-available;" />
      <p-note class="long-list" style="width: fit-content;height: 10vh; margin-top: 1em; text-align: center">
        Essendo lâ€™emissione di signal sincrona, la nostra lista Ã¨ istantaneamente aggiornata ad ogni aggiunta di un task
        tramite il bottone dedicato, evitandoci cosÃ¬ di usare la pipe async o altri metodi di sottoscrizione
      </p-note>
    </div>
  </div>
</p-slide>
<p-slide class="cover">
  <h1>In sinergia con gli Observable</h1>
</p-slide>
<p-slide>
  <p-note class="two-columns" style="align-items: center;">
    <div><img alt="code_07" src="img/export_7.png" style="height: 100vh; transform: scale(0.8)" /></div>
    <div class="two-columns" style="flex-direction: column">
      <p-note class="long-list center" style="width: fit-content;padding-top: 3em;padding-bottom: 1em">
        In questo esempio vediamo come usare in perfetta sinergia observable e signal insieme.
        Gli observable rimangono la scelta migliore per operazione asincrone. I signal risultano essere in questo
        esempio, un perfetto sostituto dei behaviour subject per condividere lo stato dellâ€™applicazione tramite service
        (e non solo).
      </p-note>
      <p-fragment style="text-align: center;width: auto;">
        <img alt="know_observable" src="img/know_observable.png" />
      </p-fragment>

      <p-fragment class="long-list infoComputed" style="position: absolute">
        La scelta di utilizzare computed Ã¨ per evitare che venga modificato il valore dallâ€™esterno del service
      </p-fragment>
      <p-fragment style="position: absolute;top: 7.4em;right: 4em;">â†©</p-fragment>
    </div>
  </p-note>
</p-slide>


<style>
  .infoComputed {
    position: absolute;
    border: 2px solid;
    text-align: center;
    font-style: italic;
    top: 18em;
    right: 6em;
    background: #FFF;
  }
</style><!--/slide:part-two-->
  <!--slide:part-three--><p-slide class="cover-subSection">
  <h1>Ultime novitÃ </h1>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row;align-items: center;">
  <p-note class="my-presentation my-list">
    <h5 class="text-cover">Signal Inputs</h5>
    <ul class="long-list">
      <li>ğŸ“Œ ModalitÃ  di gestione della logica di change input molto piÃ¹ facile</li>
      <li>ğŸ“Œ Integrazione piÃ¹ efficace con la onPush strategy</li>
      <li>ğŸ“Œ Effect sostituisce ngOnChanges</li>
      <li>ğŸ“Œ Nessuna breaking change per i componenti padre (allo stato attuale della preview)</li>
      <li>ğŸ“Œ Eâ€™ possibile definire un nome alternativo attraverso la proprietÃ  alias di input</li>
    </ul>

  </p-note>
  <p-note style="font-size: 4vh;">
    <pre class="self-center language-javascript" style="border: 1px solid #101099"> <code> export class InputComponent {
      firstName = input&lt;string>();
      // required inputs
      lastName = input.required&lt;string>();
  } </code>
      <p-fragment><code class="self-center language-html">
  &lt;app-input lastName="Doe">&lt;/app-input> </code> </p-fragment> </pre>
  </p-note>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row;align-items: center;">
  <p-note class="my-presentation my-list">
    <ul class="long-list">
      <li>Eâ€™ inoltre possibile effettuare operazioni di trasformazione alla ricezione dellâ€™input tramite la proprietÃ 
        transform, sia mantenendo il tipo di output che cambiandolo completamente
      </li>
    </ul>

  </p-note>
  <p-note style="font-size: 4vh;">
    <pre class="self-center language-javascript" style="border: 1px solid #101099"><code>export class InputComponent {
  firstName = input&lt;number, string>(0, {
  </code> <p-fragment><code>alias: 'first',
  </code></p-fragment> <p-fragment><code>transform: (value) => value.length,
 </code></p-fragment> <code>});
}
  </code><p-fragment><code class="self-center language-html">
&lt;app-input first="'Marco'">&lt;/app-input> </code></p-fragment><p-fragment> <code
      class="self-center language-javascript">

//Output: 5
</code> </p-fragment> </pre>
  </p-note>
</p-slide>
<p-slide class="two-columns-flex-start" style="flex-direction: row;align-items: center;">
  <p-note class="my-presentation my-list" style="align-items: flex-start;">
    <h6 class="text-cover">viewChild / viewChildren</h6>
    <h6 class="text-cover">contentChild / contentChildren</h6>
    <ul class="long-list" style="margin-top: 1em">
      <li>ğŸ“Œ Sostituzione dei decorators con api signal-based</li>
      <li>ğŸ“Œ Utilizzo di effect al posto dellâ€™afterviewinit lifecycle</li>
      <li>ğŸ“Œ contentChild / contentChildren possono essere usati con lo stesso approccio</li>
    </ul>

  </p-note>
  <p-note style="font-size: 4vh;">
    <pre class="self-center language-javascript" style="border: 1px solid #101099">
      <code>
  @Component({
    ...
    template: `
      &lt;h1>SomeComponent&lt;/h1>
      &lt;app-input lastName="Pollacci" />
    `,
    imports: [InputComponent],
  })
  export class SomeComponent {</code>
    <p-fragment><code>childComponent = viewChild(InputComponent);</code></p-fragment>
     <code>constructor() {</code>
      <p-fragment><code>effect(() => {
        console.log(this.childComponent()!.lastName())
        // Output: Pollacci
      })</code></p-fragment>
    <code>}
  }
      </code>
    </pre>
  </p-note>
</p-slide><!--/slide:part-three-->
  <!--slide:thanks--><p-slide>
  <img alt="thatsall" src="img/thatsall.gif" style="height: 60vh;" />
</p-slide>
<p-slide class="two-columns">
  <p-note class="my-data my-presentation">
    <h5 class="text-cover">Thank you again Folks!</h5>
    <img alt="me" class="my-face" src="img/me.jpg" />
    <span>Marco Pollacci</span>
    <span class="text-cover">Senior Software Developer @GELLIFY</span>
  </p-note>
  <img alt="qr" src="img/qr_link.png" />
</p-slide><!--/slide:thanks-->
</p-deck>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="0" class="presentation-progress" role="progressbar"
     title="Presentation progress"></div>
<div class="presentation-toolbar" role="toolbar">
  <button aria-label="Toggle speaker mode (Alt-M)" class="toggle-mode" title="Toggle speaker mode" type="button">
    <svg viewBox="0 0 1 1">
      <path d="M.05 .5h.6v-.45h-.6v.9h.6v-.45M.75 .05h.25M.75 .2h.25M.75 .35h.25" fill="none" stroke="currentColor"
            stroke-width="0.1" />
    </svg>
  </button>
  <button aria-label="Toggle fullscreen mode" class="fullscreen" title="Toggle fullscreen mode" type="button">
    <svg viewBox="0 0 1 1">
      <g fill="none" stroke="currentColor" stroke-width="0.1">
        <path d="M.05 .3v-.25h.25M.7 .05h.25v.25M.95 .7v.25h-.25M.3 .95h-.25v-.25" />
        <path d="M.05 .3h.25v-.25M.7 .05v.25h.25M.95 .7h-.25v.25M.3 .95v-.25h-.25" />
      </g>
    </svg>
  </button>
</div>
<nav class="presentation-nav">
  <button aria-label="Go backward" class="previous" title="Go backward" type="button"></button>
  <button aria-label="Go forward" class="next" title="Go forward" type="button"></button>
</nav>
<script src="js/main.js" type="module"></script>
<script src="js/presentation.js" type="module"></script>
<script defer src="vendor/prismjs/prism.js"></script>
<script defer src="vendor/prismjs/components/prism-typescript.js"></script>
<script defer src="vendor/prismjs/components/prism-scss.js"></script>
</body>
</html>
